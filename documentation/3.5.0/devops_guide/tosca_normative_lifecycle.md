---
layout: post
title:  Normative Lifecycle
root: ../../
categories: DOCUMENTATION-3.5.0
parent: [devops]
node_name: tosca_ref_normative_lifecycle
weight: 400
---

TOSCA normative lifecycle is automatically generated by the TOSCA container based on the normative node and relationship types.

{% summary %}{% endsummary %}

{% note %}
Note that the TOSCA specification on lifecycle is still being written so this may be subject to changes before v1 release.
{% endnote %}

Lifecycle is based on the normative node interface (tosca.interfaces.node.lifecycle.Standard) and relationship interface (tosca.interfaces.relationship.Configure).

# Node Lifecycle generation

1. wait for all node that is a target of a ___DependsOn___ relationship to reach the ___started___ state (current node being source of the relationship).
2. call the node's ___create___ operation
4. call the relationships ___pre_configure_source___ (if the node is the relationship source) or ___pre_configure_target___ (if the node is the relationship target)
5. call the node's ___configure___ operation
6. call the relationships ___post_configure_source___ (if the node is the relationship source) or ___post_configure_target___ (if the node is the relationship target)
7. call the node's ___start___ operation
8. call the relationships ___add_target___ (on the nodes sources) and ___add_source___ (on the nodes targets) operations.

# Environment Variables

When operation scripts are called, some environment variables are filled by the script caller.

### Node operation

For node operation script, the following variables are available:

- `NODE`: the node name.
- `INSTANCE`: the unique instance ID.
- `INSTANCES`: A comma separated list of all available instance IDs.
- `HOST`: the node name of the node that host the current one.

{%info%}
<h5> Additionnal environment variables </h5>
In addition, the folowing variables are also available:
&nbsp;&nbsp;- __Inputs parameters__: All inputs parameters defined on the operation definiton
&nbsp;&nbsp;- __Properties__: All the properties of the node and its capabilities are available following the naming:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `SELF_<PROPERTY_NAME>` for node properties
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `SELF_CAPABILITIES_<CAPABILITY_NAME>_<PROPERTY_NAME>` for capabilities properties
{%endinfo%}

### Relationship operation

For relationship operation script, the following variables are available:

- `TARGET_NODE`: The node name that is targeted by the relationship.
- `TARGET_INSTANCE`: The instance ID that is targeted by the relatonship.
- `TARGET_INSTANCES`: Comma separated list of all available instance IDs for the target node.
- `SOURCE_NODE`: The node name that is the source of the relationship.
- `SOURCE_INSTANCE`: The instance ID of the source of the relationship.
- `SOURCE_INSTANCES`: Comma separated list of all available source instance IDs.

{%info%}
<h5> Additionnal environment variables </h5>
In addition, the folowing variables are also available:
&nbsp;&nbsp;- __Inputs parameters__: All inputs parameters defined on the operation definiton
&nbsp;&nbsp;- __Properties__: All the properties of the involved nodes and capabilities are available following the naming:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `SELF_<PROPERTY_NAME>` for relationship properties
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `SOURCE_<PROPERTY_NAME>` for source node properties
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `TARGET_<PROPERTY_NAME>` for target node properties
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;* `TARGET_CAPABILITIES_<CAPABILITY_NAME>_<PROPERTY_NAME>` for targeted capability property
{%endinfo%}

### Attribute and multiple instances

When an operation defines an input, the value is available by fetching an environment variable.
If you have multiple instances, you'll be able to fetch the input value for all instances by prefixing the inpu name by the instance ID.

Let's imagine you have an relationship's configure interface operation defined like this:

{% highlight yaml %}
add_target:
  inputs:
    TARGET_IP: { get_attribute: [TARGET, ip_address] }
  implementation: scripts/add_target.sh
{% endhighlight %}

Let's imagine we have a node named `MyNodeS` with 2 instances: `MyNodeS_1`, `MyNodeS_2`.
The node `MyNodeS` is connected to the target node `MyNodeT` which has also 2 instances `MyNodeT_1` and `MyNodeT_2`.

When the `add_target.sh` script is executed for the relationship instance that connects `MyNodeS_1` to `MyNodeT_1`, the following variables will be available:

{% highlight bash %}
TARGET_NODE=MyNodeT
TARGET_INSTANCE=MyNodeT_1
TARGET_INSTANCES=MyNodeT_1,MyNodeT_2
SOURCE_NODE=MyNodeS
SOURCE_INSTANCE=MyNodeS_1
SOURCE_INSTANCES=MyNodeS_1,MyNodeS_2
TARGET_IP=192.168.0.11
MyNodeT_1_TARGET_IP=192.168.0.11
MyNodeT_2_TARGET_IP=192.168.0.12
{% endhighlight %}

{%info%}
<h5>More infos</h5>
In our samples you can find a topology [demo-lifecycle](https://github.com/alien4cloud/samples/tree/master/demo-lifecycle) that clearly demonstrate all this behavior.
Once deployed, you can find out ALL runtime available environment varibales for the different lifecycle scripts.
{%endinfo%}
